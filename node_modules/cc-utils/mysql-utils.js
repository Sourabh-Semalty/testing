"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const fs_1 = __importDefault(require("fs"));
const mysql_1 = __importDefault(require("mysql"));
const querystring_1 = __importDefault(require("querystring"));
const url_1 = __importDefault(require("url"));
const util_1 = __importDefault(require("util"));
const logger_1 = __importDefault(require("./logger"));
const readFile = util_1.default.promisify(fs_1.default.readFile);
const isDev = process.env.NODE_ENV === 'development';
async function singleQuery(connStr, sql) {
    const conn = mysql_1.default.createConnection(connStr);
    const queryPr = util_1.default.promisify(conn.query).bind(conn);
    const endPr = util_1.default.promisify(conn.end).bind(conn);
    await queryPr(sql);
    await endPr();
}
async function createDatabase(connStr) {
    const url = url_1.default.parse(connStr);
    const dbName = (url.pathname || '').substr(1);
    url.pathname = '/';
    await singleQuery(url_1.default.format(url), `CREATE DATABASE IF NOT EXISTS ${dbName}`);
}
async function importSQL(connStr, schemaFile) {
    const schemaSQL = await readFile(schemaFile, 'utf-8');
    const purl = url_1.default.parse(connStr, true);
    purl.search = querystring_1.default.stringify(Object.assign(Object.assign({}, purl.query), { multipleStatements: true }));
    await singleQuery(url_1.default.format(purl), schemaSQL);
}
const toCamelCase = (str) => str.replace(/_([a-z])/g, (chars) => chars[1].toUpperCase());
// fixRows, does two things
// change underscore to camelcase
// parse json str to json object
function fixRows(rows, fields) {
    const modFields = fields.map((f) => (Object.assign(Object.assign({}, f), { modName: toCamelCase(f.name) })));
    return rows.map((row) => {
        const modRow = {};
        for (const f of modFields) {
            const val = row[f.name];
            modRow[f.modName] = f.type === 245 && val ? JSON.parse(val) : val;
        }
        return modRow;
    });
}
const cleanSQL = (sql) => sql.replace(/[\s\n]+/g, ' ').trim();
const logger = new logger_1.default('mysql');
async function initMysqlConn(connStr, schemaFile) {
    await createDatabase(connStr);
    if (schemaFile)
        await importSQL(connStr, schemaFile);
    const myPool = mysql_1.default.createPool(connStr);
    const queryPr = (sql, params = []) => {
        if (isDev)
            logger.log(`SQL: ${cleanSQL(sql)}`, { params });
        return new Promise((resolve, reject) => {
            myPool.query(sql, params, (error, rowsOrResult, fields) => {
                if (error)
                    reject(error);
                else if (Array.isArray(rowsOrResult))
                    resolve(fixRows(rowsOrResult, fields));
                else
                    resolve(rowsOrResult);
            });
        });
    };
    const query = (sql, params) => queryPr(sql, params);
    const getRows = (sql, params) => queryPr(sql, params);
    const stream = (sql, params) => {
        if (isDev)
            logger.log(`SQL: ${cleanSQL(sql)}`);
        return myPool.query(sql, params).stream();
    };
    return {
        query,
        getRows,
        stream,
    };
}
exports.initMysqlConn = initMysqlConn;
