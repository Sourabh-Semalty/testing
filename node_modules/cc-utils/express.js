"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const express_1 = __importDefault(require("express"));
const logger_1 = __importDefault(require("./logger"));
const fs_1 = __importDefault(require("fs"));
const zlib_1 = __importDefault(require("zlib"));
const logger = new logger_1.default('express');
function action(asyncFunc) {
    const wrapFunc = async (req, res) => {
        await asyncFunc(req, res);
    };
    return function requestHandler(req, res, next) {
        wrapFunc(req, res).catch((err) => next(err));
    };
}
exports.action = action;
function asyncToNext(asyncFunc) {
    const wrapFunc = async (req, res) => {
        return await asyncFunc(req, res);
    };
    return function requestHandler(req, res, next) {
        wrapFunc(req, res)
            .then((proceed) => proceed && next())
            .catch((err) => next(err));
    };
}
exports.asyncToNext = asyncToNext;
function jaction(asyncFunc) {
    const wrapFunc = async (req, res) => {
        const result = await asyncFunc(req, res);
        return result;
    };
    return function requestHandler(req, res, next) {
        wrapFunc(req, res)
            .then((result) => res.json(result))
            .catch((err) => next(err));
    };
}
exports.jaction = jaction;
function notFound(req, res) {
    res.status(404).send('not found');
}
exports.notFound = notFound;
class ValidationError extends Error {
    constructor(errors) {
        super(JSON.stringify(errors));
        this.errors = errors;
    }
}
exports.ValidationError = ValidationError;
class NotImplementedError extends Error {
}
exports.NotImplementedError = NotImplementedError;
function errorLogger(service, err, req, res, _next) {
    if (err instanceof ValidationError) {
        res.status(400).send({ errors: err.errors });
    }
    else if (err instanceof NotImplementedError) {
        logger.errorReport(service, 'not.implemented', {
            errMessage: err.message,
        });
        res.status(501).send(err.message);
    }
    else if (err.message === 'request entity too large') {
        logger.errorReport(service, 'too.big.request', err, {
            url: req.originalUrl,
            method: req.method,
            contentType: req.get('Content-Type'),
            contentLength: req.get('Content-Length'),
        });
        if (!res.headersSent)
            res.status(413).send('Too big request');
    }
    else {
        const msg = `crash ${err.message || ''}`.substr(0, 40);
        logger.errorReport(service, msg, err, {
            url: req.originalUrl,
            method: req.method,
        });
        if (!res.headersSent)
            res.status(500).send('Internal Server Error.');
    }
}
exports.errorLogger = errorLogger;
const FIVE_MINS_IN_SECS = 60 * 5;
const ONE_HOUR_IN_SECS = 60 * 60;
const ONE_YEAR_IN_SECS = ONE_HOUR_IN_SECS * 24 * 365;
// staticCompressedJS is optimized alternative to express.static
// express.static can server only static files, it can't compress
// also its maxAge configuration is fixed for all files.
// we tried compression() module, it compresses, but caching is not good
// staticCompressedJS is optimized specially for JS,
// for other files, it fallsback to express.static
function staticCompressedJS(rootDir, devServer) {
    if (!/v12\./.test(process.version))
        throw new Error('node.js.v12.required.');
    const isDevMode = process.env.NODE_ENV === 'development' && devServer !== null;
    if (isDevMode) {
        // in dev mode, don't compress js, redirect to webpack server
        return (req, res) => {
            res.redirect(`${devServer}${req.originalUrl}`);
        };
    }
    else {
        // scan folder, find js files, brotli zip and keep them ready in cache
        // if you find 'bundle.[hash].cache.js files store its name in variable
        // we have to redirect to this file, when bundle.js is requested
        const cache = {};
        let bundleFile = null;
        if (fs_1.default.existsSync(rootDir)) {
            const jsFiles = fs_1.default.readdirSync(rootDir).filter((n) => /\.js$/.test(n));
            for (const f of jsFiles) {
                if (/^bundle\..*\.js$/.test(f))
                    bundleFile = f;
                cache[`/${f}`] = zlib_1.default.brotliCompressSync(fs_1.default.readFileSync(`${rootDir}/${f}`));
            }
        }
        // does browser supports brotli ?
        const isBrotliSupported = (req) => /\bbr\b/.test(req.get('Accept-Encoding') || '');
        // actual middleware
        // if the file name have .cache.js , then cache it for year otherwise a hour
        const expStatic = express_1.default.static(rootDir);
        return (req, res, next) => {
            if (req.url === '/bundle.js' && bundleFile) {
                res
                    .set('Cache-Control', `private, max-age=${FIVE_MINS_IN_SECS}`)
                    .redirect(bundleFile);
            }
            else if (cache[req.url] && isBrotliSupported(req)) {
                const maxAge = /\.cache\.js$/.test(req.url) ? ONE_YEAR_IN_SECS : ONE_HOUR_IN_SECS;
                res
                    .type('js')
                    .set('Content-Encoding', 'br')
                    .set('Cache-Control', `public, max-age=${maxAge}`)
                    .send(cache[req.url]);
            }
            else {
                // fallback to next middleware, use express.static as next middleware
                expStatic(req, res, next);
            }
        };
    }
}
exports.staticCompressedJS = staticCompressedJS;
