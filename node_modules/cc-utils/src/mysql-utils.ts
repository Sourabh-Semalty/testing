import fs from 'fs';
import mysql from 'mysql';
import querystring from 'querystring';
import stream from 'stream';
import urlm from 'url';
import util from 'util';
import Logger from './logger';

const readFile = util.promisify(fs.readFile);
const isDev = process.env.NODE_ENV === 'development';

async function singleQuery(connStr: string, sql: string) {
  const conn = mysql.createConnection(connStr);
  const queryPr = util.promisify(conn.query).bind(conn);
  const endPr = util.promisify(conn.end).bind(conn);
  await queryPr(sql);
  await endPr();
}

async function createDatabase(connStr: string) {
  const url = urlm.parse(connStr);
  const dbName = (url.pathname || '').substr(1);
  url.pathname = '/';
  await singleQuery(urlm.format(url), `CREATE DATABASE IF NOT EXISTS ${dbName}`);
}

async function importSQL(connStr: string, schemaFile: string) {
  const schemaSQL = await readFile(schemaFile, 'utf-8');
  const purl = urlm.parse(connStr, true);
  purl.search = querystring.stringify({ ...purl.query, multipleStatements: true });
  await singleQuery(urlm.format(purl), schemaSQL);
}

const toCamelCase = (str: string) =>
  str.replace(/_([a-z])/g, (chars) => chars[1].toUpperCase());

// fixRows, does two things
// change underscore to camelcase
// parse json str to json object
function fixRows(rows: any[], fields: mysql.FieldInfo[]) {
  const modFields = fields.map((f) => ({ ...f, modName: toCamelCase(f.name) }));
  return rows.map((row) => {
    const modRow: any = {};
    for (const f of modFields) {
      const val = row[f.name];
      modRow[f.modName] = f.type === 245 && val ? JSON.parse(val) : val;
    }
    return modRow;
  });
}

export interface IDbUtils {
  query(sql: string, params?: any[]): Promise<any>;
  getRows(sql: string, params?: any[]): Promise<any[]>;
  stream(sql: string, params?: any[]): stream.Readable;
}

const cleanSQL = (sql: string) => sql.replace(/[\s\n]+/g, ' ').trim();

const logger = new Logger('mysql');

export async function initMysqlConn(
  connStr: string,
  schemaFile?: string
): Promise<IDbUtils> {
  await createDatabase(connStr);
  if (schemaFile) await importSQL(connStr, schemaFile);
  const myPool = mysql.createPool(connStr);
  const queryPr = (sql: string, params: any[] = []) => {
    if (isDev) logger.log(`SQL: ${cleanSQL(sql)}`, { params });
    return new Promise<any>((resolve, reject) => {
      myPool.query(sql, params, (error, rowsOrResult, fields) => {
        if (error) reject(error);
        else if (Array.isArray(rowsOrResult)) resolve(fixRows(rowsOrResult, fields!));
        else resolve(rowsOrResult);
      });
    });
  };
  const query = (sql: string, params?: any[]): Promise<any> => queryPr(sql, params);
  const getRows = (sql: string, params?: any[]): Promise<any[]> => queryPr(sql, params);
  const stream = (sql: string, params?: any[]) => {
    if (isDev) logger.log(`SQL: ${cleanSQL(sql)}`);
    return myPool.query(sql, params).stream();
  };
  return {
    query,
    getRows,
    stream,
  };
}
