import fs from 'fs';
import util from 'util';
import urlm from 'url';
import { Pool, Client, QueryResult } from 'pg';
import Logger from './logger';

const readFile = util.promisify(fs.readFile);
const isDev = process.env.NODE_ENV === 'development';

async function createDatabase(connStr: string) {
  const url = urlm.parse(connStr);
  const dbName = (url.pathname || '').substr(1);
  url.pathname = '/postgres'; // change database name to default 'postgres'
  const client = new Client({ connectionString: urlm.format(url) });
  await client.connect();
  const SELECT_QUERY = 'SELECT 1 FROM pg_database WHERE datname = $1';
  const result = await client.query(SELECT_QUERY, [dbName]);
  if (!result.rowCount) await client.query(`CREATE DATABASE "${dbName}"`);
  await client.end();
}

function toCamelCase(row: any) {
  const mod: any = {};
  for (const key of Object.keys(row)) {
    const camelKey = key.replace(/_([a-z])/g, (chars) => chars[1].toUpperCase());
    mod[camelKey] = row[key];
  }
  return mod;
}

export interface IDbUtils {
  query(sql: string, params?: any[]): Promise<QueryResult>;
  getRows(sql: string, params?: any[]): Promise<any[]>;
}

const cleanSQL = (sql: string) => sql.replace(/[\s\n]+/g, ' ').trim();

const logger = new Logger('pg');
export async function initPgConn(
  connStr: string,
  schemaFile?: string
): Promise<IDbUtils> {
  await createDatabase(connStr);
  const pgPool = new Pool({ connectionString: connStr });

  if (schemaFile) {
    const schemaSQL = await readFile(schemaFile, 'utf-8');
    await pgPool.query(schemaSQL);
  }

  const query = async (sql: string, params?: any[]) => {
    if (isDev) logger.log(`SQL ${cleanSQL(sql)}`);
    return pgPool.query(sql, params);
  };
  const getRows = async (sql: string, params?: any[]) => {
    const result = await query(sql, params);
    return result.rows.map(toCamelCase);
  };
  return {
    query,
    getRows,
  };
}
