import express, { Request, Response, NextFunction } from 'express';
import Logger from './logger';
import fs from 'fs';
import zlib from 'zlib';

const logger = new Logger('express');

export function action(asyncFunc: Function) {
  const wrapFunc = async (req: Request, res: Response) => {
    await asyncFunc(req, res);
  };
  return function requestHandler(req: Request, res: Response, next: NextFunction) {
    wrapFunc(req, res).catch((err) => next(err));
  };
}

export function asyncToNext(asyncFunc: (req: Request, res: Response) => boolean) {
  const wrapFunc = async (req: Request, res: Response) => {
    return await asyncFunc(req, res);
  };
  return function requestHandler(req: Request, res: Response, next: NextFunction) {
    wrapFunc(req, res)
      .then((proceed) => proceed && next())
      .catch((err) => next(err));
  };
}

export function jaction(asyncFunc: Function) {
  const wrapFunc = async (req: Request, res: Response) => {
    const result = await asyncFunc(req, res);
    return result;
  };
  return function requestHandler(req: Request, res: Response, next: NextFunction) {
    wrapFunc(req, res)
      .then((result) => res.json(result))
      .catch((err) => next(err));
  };
}

export function notFound(req: Request, res: Response) {
  res.status(404).send('not found');
}

export class ValidationError extends Error {
  errors?: Object;
  constructor(errors: Object) {
    super(JSON.stringify(errors));
    this.errors = errors;
  }
}

export class NotImplementedError extends Error {}

export function errorLogger(
  service: string,
  err: Error,
  req: Request,
  res: Response,
  _next: NextFunction
) {
  if (err instanceof ValidationError) {
    res.status(400).send({ errors: err.errors });
  } else if (err instanceof NotImplementedError) {
    logger.errorReport(service, 'not.implemented', {
      errMessage: err.message,
    });
    res.status(501).send(err.message);
  } else if (err.message === 'request entity too large') {
    logger.errorReport(service, 'too.big.request', err, {
      url: req.originalUrl,
      method: req.method,
      contentType: req.get('Content-Type'),
      contentLength: req.get('Content-Length'),
    });
    if (!res.headersSent) res.status(413).send('Too big request');
  } else {
    const msg = `crash ${err.message || ''}`.substr(0, 40);
    logger.errorReport(service, msg, err, {
      url: req.originalUrl,
      method: req.method,
    });
    if (!res.headersSent) res.status(500).send('Internal Server Error.');
  }
}

const FIVE_MINS_IN_SECS = 60 * 5;
const ONE_HOUR_IN_SECS = 60 * 60;
const ONE_YEAR_IN_SECS = ONE_HOUR_IN_SECS * 24 * 365;
// staticCompressedJS is optimized alternative to express.static
// express.static can server only static files, it can't compress
// also its maxAge configuration is fixed for all files.
// we tried compression() module, it compresses, but caching is not good
// staticCompressedJS is optimized specially for JS,
// for other files, it fallsback to express.static
export function staticCompressedJS(rootDir: string, devServer: string | null) {
  if (!/v12\./.test(process.version)) throw new Error('node.js.v12.required.');

  const isDevMode = process.env.NODE_ENV === 'development' && devServer !== null;

  if (isDevMode) {
    // in dev mode, don't compress js, redirect to webpack server
    return (req: Request, res: Response) => {
      res.redirect(`${devServer}${req.originalUrl}`);
    };
  } else {
    // scan folder, find js files, brotli zip and keep them ready in cache
    // if you find 'bundle.[hash].cache.js files store its name in variable
    // we have to redirect to this file, when bundle.js is requested
    const cache: { [key: string]: Buffer } = {};
    let bundleFile: string | null = null;
    if (fs.existsSync(rootDir)) {
      const jsFiles = fs.readdirSync(rootDir).filter((n) => /\.js$/.test(n));
      for (const f of jsFiles) {
        if (/^bundle\..*\.js$/.test(f)) bundleFile = f;
        cache[`/${f}`] = zlib.brotliCompressSync(fs.readFileSync(`${rootDir}/${f}`));
      }
    }

    // does browser supports brotli ?
    const isBrotliSupported = (req: Request) =>
      /\bbr\b/.test(req.get('Accept-Encoding') || '');

    // actual middleware
    // if the file name have .cache.js , then cache it for year otherwise a hour
    const expStatic = express.static(rootDir);
    return (req: Request, res: Response, next: NextFunction) => {
      if (req.url === '/bundle.js' && bundleFile) {
        res
          .set('Cache-Control', `private, max-age=${FIVE_MINS_IN_SECS}`)
          .redirect(bundleFile);
      } else if (cache[req.url] && isBrotliSupported(req)) {
        const maxAge = /\.cache\.js$/.test(req.url) ? ONE_YEAR_IN_SECS : ONE_HOUR_IN_SECS;
        res
          .type('js')
          .set('Content-Encoding', 'br')
          .set('Cache-Control', `public, max-age=${maxAge}`)
          .send(cache[req.url]);
      } else {
        // fallback to next middleware, use express.static as next middleware
        expStatic(req, res, next);
      }
    };
  }
}
