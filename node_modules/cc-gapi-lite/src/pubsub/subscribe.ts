import Logger from 'cc-utils/logger';
import GoogleAPI from '../gapi-lite';
const logger = new Logger('pubsub');

const SECOND = 1000;

const api = new GoogleAPI(['https://www.googleapis.com/auth/pubsub']);
const prjPrefix = 'https://pubsub.googleapis.com/v1/projects';
let stopAll = false;
let subscribersCount = 0;

async function sleep(delay: number) {
  return new Promise((resolve) => setTimeout(resolve, delay));
}

async function timeout(fn: Function, maxTime: number, message: string): Promise<any> {
  return new Promise((resolve, reject) => {
    const timer = setTimeout(() => reject(new Error(`timeout.${message}`)), maxTime);
    fn()
      .then((result: any) => {
        clearTimeout(timer);
        resolve(result);
      })
      .catch(reject);
  });
}

export interface SubscribeOptions {
  concurrency: number;
  execTimeout: number;
}
interface ReceivedMessage {
  message: PubsubMessage;
  ackId: string;
}
interface PubsubMessage {
  publishTime: string;
  data: string;
}

interface SubscribeFunction {
  (payload: {}, pmsg: PubsubMessage): Promise<any>;
}

// PubSubPullManager will pull, execute, and ack, track parallel executions
class PubSubPullManager {
  private curRunning = 0;
  constructor(
    private subName: string,
    private execFunc: SubscribeFunction,
    private opts: SubscribeOptions
  ) {}
  async pullOnce() {
    const maxMessages = this.opts.concurrency - this.curRunning;
    if (maxMessages) {
      const endPoint = `${prjPrefix}/${this.subName}:pull`;
      const resp: any = await api.request(endPoint, {
        method: 'POST',
        json: { maxMessages },
        ccRetry: true,
      });
      if (!stopAll) {
        (resp.receivedMessages || []).forEach((pubMsg: ReceivedMessage) =>
          this.launchExec(pubMsg)
        );
      }
    } else {
      await sleep(100);
    }
  }
  async ackMessage(ackId: string) {
    const endpoint = `${prjPrefix}/${this.subName}:acknowledge`;
    await api.request(endpoint, {
      method: 'POST',
      json: { ackIds: [ackId] },
      ccRetry: true,
    });
  }
  async launchExec(pubMsg: ReceivedMessage) {
    let jsonPayload: any;
    try {
      this.curRunning += 1;
      const imsg = pubMsg.message;
      const jsonPayloadStr = Buffer.from(imsg.data, 'base64').toString();
      jsonPayload = JSON.parse(jsonPayloadStr);
      await timeout(
        async () => {
          await this.execFunc(jsonPayload, imsg);
          await this.ackMessage(pubMsg.ackId);
        },
        this.opts.execTimeout,
        'pubsub.exec'
      );
    } catch (err) {
      logger.error('pubsub.exec', err, { subName: this.subName, jsonPayload });
    } finally {
      this.curRunning -= 1;
    }
  }
}

const MIN = 1000 * 60;
export function subscribe(
  subName: string,
  execFunc: SubscribeFunction,
  opts: SubscribeOptions = { concurrency: 8, execTimeout: 10 * SECOND }
) {
  subscribersCount += 1;
  logger.log('subscribing', { subName });
  const mgr = new PubSubPullManager(subName, execFunc, opts);
  (async () => {
    while (!stopAll) {
      try {
        await timeout(() => mgr.pullOnce(), 2 * MIN, 'pubsub.loop');
      } catch (timeoutErr) {
        logger.error('pubsub.timeout', timeoutErr, { subName });
      }
    }
  })();
}

const stopSubscribers = () => {
  if (subscribersCount > 0) console.log('pubsub.interrupt');
  stopAll = true;
};

process.once('SIGINT', stopSubscribers);
process.once('SIGTERM', stopSubscribers);
