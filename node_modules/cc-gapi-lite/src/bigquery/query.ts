import Logger from 'cc-utils/logger';
import { HTTPError } from 'got';
import GoogleAPI from '../gapi-lite';
import {
  BigQueryResponse,
  BQParam,
  BQParamArrayValue,
  BQParamType,
  BQParamValue,
  BQParsedPaginatedResponse,
  BQParsedResponse,
  BQRow,
  BQTableCell,
  IPaginationOptions,
  QueryParams,
  QueryParamType,
} from './types';

export enum ParamType {
  String = 'STRING',
  Integer = 'INTEGER',
  Float = 'FLOAT',
  TimeStamp = 'TIMESTAMP',
  Boolean = 'BOOL',
  Array = 'ARRAY',
}

type StrBoolNumDate = string | boolean | number | Date;

const scopes = [
  'https://www.googleapis.com/auth/bigquery',
  'https://www.googleapis.com/auth/drive',
];
const prjPrefix = 'https://www.googleapis.com/bigquery/v2/projects';
const logger = new Logger('big-query');

const removeSpace = (str: string) => str.replace(/\s+/g, ' ');

function isNoMatchingTables(err: Error) {
  if (err instanceof HTTPError) {
    const msg = (err.response as any)?.error?.message;
    return msg === 'FROM clause with table wildcards matches no table';
  } else {
    return false;
  }
}

const is404 = (err: { statusCode?: number }) => err.statusCode === 404;

const delay = (ms: number) => new Promise((resolve) => setTimeout(resolve, ms));

let singleton: GoogleAPI | null = null;
function getGAPI() {
  if (!singleton) singleton = new GoogleAPI(scopes);
  return singleton;
}

async function waitForQueryComplete(projectId: string, resp: any): Promise<any> {
  const { jobId } = resp.jobReference;
  if (resp.jobComplete) {
    if (resp.pageToken) {
      const { rows: prevRows, pageToken } = resp;
      const nextResp = await getGAPI().request(
        `${prjPrefix}/${projectId}/queries/${jobId}`,
        {
          method: 'GET',
          searchParams: { pageToken },
        }
      );
      nextResp.rows = prevRows.concat(nextResp.rows);
      return waitForQueryComplete(projectId, nextResp);
    } else {
      return resp;
    }
  } else {
    await delay(500);
    const resp2 = await getGAPI().request(`${prjPrefix}/${projectId}/queries/${jobId}`, {
      method: 'GET',
    });
    return waitForQueryComplete(projectId, resp2);
  }
}

const emptyTable = (): any => ({ columns: [], rows: [] });

// returns field parser function
// this function wont parse the field, but it will return function, that
// can be used for parsing
function getFieldParser(field: any): Function {
  const { type, fields: subFields } = field;
  if (type === 'INTEGER') {
    return (valStr: string) => (valStr === null ? null : parseInt(valStr, 10));
  } else if (type === 'FLOAT') {
    return (valStr: string) => (valStr === null ? null : parseFloat(valStr));
  } else if (type === 'TIMESTAMP') {
    return (valStr: string) =>
      valStr === null ? null : new Date(parseFloat(valStr) * 1000);
  } else if (type === 'BOOLEAN') {
    return (valStr: string) => (valStr === null ? null : valStr === 'true');
  } else if (type === 'RECORD') {
    const cellParsers = subFields.map(getFieldParser);
    // for every row in repeated record
    // for ever cell in row
    // parse cell
    return (valArray: BQRow | BQTableCell[]) => {
      if (Array.isArray(valArray)) {
        return valArray.map((rec) => {
          const exists = rec && rec.v && rec.v.f;
          if (exists)
            return rec.v.f.map((cell: BQTableCell, celli: number) =>
              cellParsers[celli](cell.v)
            );
          else return [];
        });
      } else {
        if (valArray.f && Array.isArray(valArray.f)) {
          return valArray.f.map((cell: BQTableCell, celli: number) =>
            cellParsers[celli](cell.v)
          );
        } else {
          return valArray;
        }
      }
    };
  } else {
    return (valStr: any) => valStr;
  }
}

function isSameType(value1: StrBoolNumDate, value2: StrBoolNumDate) {
  return (
    (value1 instanceof Date && value2 instanceof Date) || typeof value1 === typeof value2
  );
}

function getParamType(key: string, value: QueryParamType): BQParamType {
  if (value === null) {
    throw new Error(`Query parameter '${key}': Null value not allowed`);
  } else if (typeof value === 'boolean') {
    return { type: ParamType.Boolean };
  } else if (typeof value === 'string') {
    return { type: ParamType.String };
  } else if (typeof value === 'number') {
    return Number.isInteger(value)
      ? { type: ParamType.Integer }
      : { type: ParamType.Float };
  } else if (value instanceof Date) {
    return { type: ParamType.TimeStamp };
  } else if (Array.isArray(value)) {
    if (value.length) {
      const isUniformArray = value.every((val: StrBoolNumDate) =>
        isSameType(val, value[0])
      );
      if (isUniformArray) {
        const firstElemType = getParamType(key, value[0]);
        return {
          type: ParamType.Array,
          arrayType: firstElemType,
        };
      } else {
        throw new Error(`Query parameter '${key}': Array must have uniform values`);
      }
    } else {
      throw new Error(`Query parameter '${key}': Empty array not allowed`);
    }
  } else {
    throw new Error(
      `Query parameter '${key}': Invalid Parameter Type ${JSON.stringify(value)}`
    );
  }
}

const convertValue = (value: StrBoolNumDate) =>
  value instanceof Date ? value.toISOString() : `${value}`;

function getParamValue(value: QueryParamType): BQParamValue | BQParamArrayValue {
  if (Array.isArray(value)) {
    const arrVal = value as StrBoolNumDate[];
    return { arrayValues: arrVal.map((val) => ({ value: convertValue(val) })) };
  } else {
    return { value: convertValue(value) };
  }
}

function buildParams(params: QueryParams): BQParam[] {
  return Object.keys(params).map((key) => ({
    name: key,
    parameterType: getParamType(key, params[key]),
    parameterValue: getParamValue(params[key]),
  }));
}

export default async function query(
  projectId: string,
  querySQL: string,
  params: QueryParams = {}
): Promise<BQParsedResponse> {
  const debugQuery = removeSpace(querySQL);
  const qParams = buildParams(params);
  const start = Date.now();
  let resp2;
  try {
    resp2 = await getGAPI().request(`${prjPrefix}/${projectId}/queries`, {
      method: 'POST',
      json: {
        query: querySQL,
        queryParameters: qParams,
        useLegacySql: false,
        parameterMode: 'NAMED',
      },
    });
  } catch (err) {
    if (is404(err) || isNoMatchingTables(err)) {
      logger.log(`bquery.404 ${debugQuery}`);
      return emptyTable();
    } else {
      logger.error(`bigquery.fail ${debugQuery}`);
      throw err;
    }
  }
  const resp: BigQueryResponse = await waitForQueryComplete(projectId, resp2);
  const took = Date.now() - start;
  const cost = resp.cacheHit ? 'cached' : resp.totalBytesProcessed;
  logger.log(JSON.stringify({ module: 'bigquery', took, cost, query: debugQuery }));
  const { fields } = resp.schema;
  const fieldParsers = fields.map(getFieldParser);
  const rowParser = (bqRow: BQRow) => bqRow.f.map((cell, i) => fieldParsers[i](cell.v));
  return { columns: fields, rows: (resp.rows || []).map(rowParser) };
}

async function waitForPaginationQueryComplete(
  projectId: string,
  resp: any
): Promise<any> {
  const { jobId } = resp.jobReference;
  if (resp.jobComplete) {
    return resp;
  } else {
    await delay(500);
    const resp2 = await getGAPI().request(`${prjPrefix}/${projectId}/queries/${jobId}`, {
      method: 'GET',
    });
    return waitForPaginationQueryComplete(projectId, resp2);
  }
}

export async function queryWithPagination(
  projectId: string,
  querySQL: string,
  params: QueryParams = {},
  options: IPaginationOptions = {}
): Promise<BQParsedPaginatedResponse> {
  const { maxResults = 20, jobId, pageToken } = options;
  let resp;
  const debugQuery = removeSpace(querySQL);
  const qParams = buildParams(params);
  try {
    if (pageToken && jobId) {
      resp = await getGAPI().request(`${prjPrefix}/${projectId}/queries/${jobId}`, {
        method: 'GET',
        searchParams: { pageToken, ...params },
      });
    } else {
      const resp2 = await getGAPI().request(`${prjPrefix}/${projectId}/queries`, {
        method: 'POST',
        json: {
          query: querySQL,
          queryParameters: qParams,
          useLegacySql: false,
          parameterMode: 'NAMED',
          maxResults,
        },
      });
      resp = await waitForPaginationQueryComplete(projectId, resp2);
    }
  } catch (err) {
    if (is404(err) || isNoMatchingTables(err)) {
      logger.log(`bquery.404 ${debugQuery}`);
      return emptyTable();
    } else {
      logger.error(`bigquery.fail ${debugQuery}`);
      throw err;
    }
  }

  const start = Date.now();
  const took = Date.now() - start;
  const cost = resp.cacheHit ? 'cached' : resp.totalBytesProcessed;
  logger.log(JSON.stringify({ module: 'bigquery', took, cost, query: debugQuery }));

  const { fields } = resp.schema;
  const fieldParsers = fields.map(getFieldParser);
  const rowParser = (bqRow: BQRow) => bqRow.f.map((cell, i) => fieldParsers[i](cell.v));
  return {
    columns: fields,
    rows: (resp.rows || []).map(rowParser),
    pageToken: resp?.pageToken,
    jobId: resp?.jobReference?.jobId,
    totalRows: resp?.totalRows,
  };
}
