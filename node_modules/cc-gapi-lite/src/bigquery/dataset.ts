import GoogleAPI from '../gapi-lite';
import Logger from 'cc-utils/logger';

const scopes = ['https://www.googleapis.com/auth/bigquery'];
const apiBase = 'https://www.googleapis.com/bigquery/v2/projects';

let singleton: GoogleAPI | null = null;
function getGAPI() {
  if (!singleton) singleton = new GoogleAPI(scopes);
  return singleton;
}

export enum FieldType {
  String = 'STRING',
  Integer = 'INTEGER',
  Float = 'FLOAT',
  TimeStamp = 'TIMESTAMP',
  Record = 'RECORD',
  Boolean = 'BOOLEAN',
}
export enum FieldMode {
  Required = 'REQUIRED',
  Repeated = 'REPEATED',
}
export interface ITableField {
  name: string;
  type: FieldType;
  mode: FieldMode;
  fields: ITableField[];
}
export interface ITableSchema {
  fields: [ITableField];
}
export interface TableInfo {
  schema: ITableSchema;
}
export enum JobState {
  Done = 'DONE',
  Pending = 'PENDING',
  Running = 'RUNNING',
}
export interface JobStatus {
  state: JobState;
  errorResult: any;
  errors: [any];
}
export interface JobInfo {
  status: JobStatus;
}
export interface ITimePartition {
  type: string;
  field: string;
}
export interface IExtDataConfig {
  sourceUris: string[];
  compression?: 'GZIP' | 'NONE';
  sourceFormat?: 'NEWLINE_DELIMITED_JSON';
  schema?: ITableSchema;
}
export interface ITableResource {
  schema?: ITableSchema;
  timePartitioning?: ITimePartition;
  externalDataConfiguration?: IExtDataConfig;
}

const logger = new Logger('bq-dataset');
export class Dataset {
  constructor(private projectId: string, private datasetId: string) {}
  async getTableInfo(tableId: string): Promise<TableInfo | null> {
    const { projectId, datasetId } = this;
    return getGAPI().tryGet(
      `${apiBase}/${projectId}/datasets/${datasetId}/tables/${tableId}`
    );
  }
  async getJob(jobId: string): Promise<JobInfo | null> {
    const { projectId } = this;
    return getGAPI().tryGet(`${apiBase}/${projectId}/jobs/${jobId}`);
  }
  async createLoadJob(tableId: string, jobId: string, gsURI: string): Promise<void> {
    const { projectId, datasetId } = this;
    await getGAPI().request(`${apiBase}/${projectId}/jobs`, {
      method: 'POST',
      searchParams: { uploadType: 'multipart' },
      json: {
        jobReference: { projectId, jobId },
        configuration: {
          load: {
            destinationTable: { projectId: projectId, datasetId, tableId },
            sourceFormat: 'NEWLINE_DELIMITED_JSON',
            sourceUris: [gsURI],
          },
        },
      },
    });
  }
  async createTable(tableId: string, tblResource: ITableResource) {
    const { projectId, datasetId } = this;
    await getGAPI().request(`${apiBase}/${projectId}/datasets/${datasetId}/tables`, {
      method: 'POST',
      json: {
        tableReference: { projectId, datasetId, tableId },
        ...tblResource,
      },
    });
  }
  async patchTable(tableId: string, tblResource: ITableResource) {
    const { projectId, datasetId } = this;
    await getGAPI().request(
      `${apiBase}/${projectId}/datasets/${datasetId}/tables/${tableId}`,
      {
        method: 'PATCH',
        json: {
          tableReference: { projectId, datasetId, tableId },
          ...tblResource,
        },
      }
    );
  }
  async createTableIfNotExists(tableId: string): Promise<ITableSchema> {
    let tblInfo = await this.getTableInfo(tableId);
    if (tblInfo === null) {
      if (/_[a-z0-9_]+$/.test(tableId)) {
        // if it is domain table, copy schema from reference table
        const refTableId = tableId.replace(/_[a-z0-9_]+$/, '').replace(/^test/, '');
        const refTblInfo: ITableResource | null = await this.getTableInfo(refTableId);
        if (refTblInfo === null || !refTblInfo.schema) {
          throw new Error(`missing.refTable.schema ${refTableId}:${tableId}`);
        } else {
          let newResource: ITableResource = {};
          if (refTblInfo.externalDataConfiguration) {
            newResource.externalDataConfiguration = refTblInfo.externalDataConfiguration;
            newResource.externalDataConfiguration.schema = refTblInfo.schema;
          } else {
            newResource.schema = refTblInfo.schema;
            newResource.timePartitioning = refTblInfo.timePartitioning;
          }
          logger.log('bq.create', { tableId, refTableId, newResource });
          await this.createTable(tableId, newResource);
          return refTblInfo.schema;
        }
      } else {
        throw new Error(`missing.table.schema ${tableId}`);
      }
    } else {
      return tblInfo.schema;
    }
  }
}
