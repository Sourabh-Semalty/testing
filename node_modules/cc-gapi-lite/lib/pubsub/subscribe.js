"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.subscribe = void 0;
const logger_1 = __importDefault(require("cc-utils/logger"));
const gapi_lite_1 = __importDefault(require("../gapi-lite"));
const logger = new logger_1.default('pubsub');
const SECOND = 1000;
const api = new gapi_lite_1.default(['https://www.googleapis.com/auth/pubsub']);
const prjPrefix = 'https://pubsub.googleapis.com/v1/projects';
let stopAll = false;
let subscribersCount = 0;
async function sleep(delay) {
    return new Promise((resolve) => setTimeout(resolve, delay));
}
async function timeout(fn, maxTime, message) {
    return new Promise((resolve, reject) => {
        const timer = setTimeout(() => reject(new Error(`timeout.${message}`)), maxTime);
        fn()
            .then((result) => {
            clearTimeout(timer);
            resolve(result);
        })
            .catch(reject);
    });
}
// PubSubPullManager will pull, execute, and ack, track parallel executions
class PubSubPullManager {
    constructor(subName, execFunc, opts) {
        this.subName = subName;
        this.execFunc = execFunc;
        this.opts = opts;
        this.curRunning = 0;
    }
    async pullOnce() {
        const maxMessages = this.opts.concurrency - this.curRunning;
        if (maxMessages) {
            const endPoint = `${prjPrefix}/${this.subName}:pull`;
            const resp = await api.request(endPoint, {
                method: 'POST',
                json: { maxMessages },
                ccRetry: true,
            });
            if (!stopAll) {
                (resp.receivedMessages || []).forEach((pubMsg) => this.launchExec(pubMsg));
            }
        }
        else {
            await sleep(100);
        }
    }
    async ackMessage(ackId) {
        const endpoint = `${prjPrefix}/${this.subName}:acknowledge`;
        await api.request(endpoint, {
            method: 'POST',
            json: { ackIds: [ackId] },
            ccRetry: true,
        });
    }
    async launchExec(pubMsg) {
        let jsonPayload;
        try {
            this.curRunning += 1;
            const imsg = pubMsg.message;
            const jsonPayloadStr = Buffer.from(imsg.data, 'base64').toString();
            jsonPayload = JSON.parse(jsonPayloadStr);
            await timeout(async () => {
                await this.execFunc(jsonPayload, imsg);
                await this.ackMessage(pubMsg.ackId);
            }, this.opts.execTimeout, 'pubsub.exec');
        }
        catch (err) {
            logger.error('pubsub.exec', err, { subName: this.subName, jsonPayload });
        }
        finally {
            this.curRunning -= 1;
        }
    }
}
const MIN = 1000 * 60;
function subscribe(subName, execFunc, opts = { concurrency: 8, execTimeout: 10 * SECOND }) {
    subscribersCount += 1;
    logger.log('subscribing', { subName });
    const mgr = new PubSubPullManager(subName, execFunc, opts);
    (async () => {
        while (!stopAll) {
            try {
                await timeout(() => mgr.pullOnce(), 2 * MIN, 'pubsub.loop');
            }
            catch (timeoutErr) {
                logger.error('pubsub.timeout', timeoutErr, { subName });
            }
        }
    })();
}
exports.subscribe = subscribe;
const stopSubscribers = () => {
    if (subscribersCount > 0)
        console.log('pubsub.interrupt');
    stopAll = true;
};
process.once('SIGINT', stopSubscribers);
process.once('SIGTERM', stopSubscribers);
