"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.queryWithPagination = exports.ParamType = void 0;
const logger_1 = __importDefault(require("cc-utils/logger"));
const got_1 = require("got");
const gapi_lite_1 = __importDefault(require("../gapi-lite"));
var ParamType;
(function (ParamType) {
    ParamType["String"] = "STRING";
    ParamType["Integer"] = "INTEGER";
    ParamType["Float"] = "FLOAT";
    ParamType["TimeStamp"] = "TIMESTAMP";
    ParamType["Boolean"] = "BOOL";
    ParamType["Array"] = "ARRAY";
})(ParamType = exports.ParamType || (exports.ParamType = {}));
const scopes = [
    'https://www.googleapis.com/auth/bigquery',
    'https://www.googleapis.com/auth/drive',
];
const prjPrefix = 'https://www.googleapis.com/bigquery/v2/projects';
const logger = new logger_1.default('big-query');
const removeSpace = (str) => str.replace(/\s+/g, ' ');
function isNoMatchingTables(err) {
    var _a, _b;
    if (err instanceof got_1.HTTPError) {
        const msg = (_b = (_a = err.response) === null || _a === void 0 ? void 0 : _a.error) === null || _b === void 0 ? void 0 : _b.message;
        return msg === 'FROM clause with table wildcards matches no table';
    }
    else {
        return false;
    }
}
const is404 = (err) => err.statusCode === 404;
const delay = (ms) => new Promise((resolve) => setTimeout(resolve, ms));
let singleton = null;
function getGAPI() {
    if (!singleton)
        singleton = new gapi_lite_1.default(scopes);
    return singleton;
}
async function waitForQueryComplete(projectId, resp) {
    const { jobId } = resp.jobReference;
    if (resp.jobComplete) {
        if (resp.pageToken) {
            const { rows: prevRows, pageToken } = resp;
            const nextResp = await getGAPI().request(`${prjPrefix}/${projectId}/queries/${jobId}`, {
                method: 'GET',
                searchParams: { pageToken },
            });
            nextResp.rows = prevRows.concat(nextResp.rows);
            return waitForQueryComplete(projectId, nextResp);
        }
        else {
            return resp;
        }
    }
    else {
        await delay(500);
        const resp2 = await getGAPI().request(`${prjPrefix}/${projectId}/queries/${jobId}`, {
            method: 'GET',
        });
        return waitForQueryComplete(projectId, resp2);
    }
}
const emptyTable = () => ({ columns: [], rows: [] });
// returns field parser function
// this function wont parse the field, but it will return function, that
// can be used for parsing
function getFieldParser(field) {
    const { type, fields: subFields } = field;
    if (type === 'INTEGER') {
        return (valStr) => (valStr === null ? null : parseInt(valStr, 10));
    }
    else if (type === 'FLOAT') {
        return (valStr) => (valStr === null ? null : parseFloat(valStr));
    }
    else if (type === 'TIMESTAMP') {
        return (valStr) => valStr === null ? null : new Date(parseFloat(valStr) * 1000);
    }
    else if (type === 'BOOLEAN') {
        return (valStr) => (valStr === null ? null : valStr === 'true');
    }
    else if (type === 'RECORD') {
        const cellParsers = subFields.map(getFieldParser);
        // for every row in repeated record
        // for ever cell in row
        // parse cell
        return (valArray) => {
            if (Array.isArray(valArray)) {
                return valArray.map((rec) => {
                    const exists = rec && rec.v && rec.v.f;
                    if (exists)
                        return rec.v.f.map((cell, celli) => cellParsers[celli](cell.v));
                    else
                        return [];
                });
            }
            else {
                if (valArray.f && Array.isArray(valArray.f)) {
                    return valArray.f.map((cell, celli) => cellParsers[celli](cell.v));
                }
                else {
                    return valArray;
                }
            }
        };
    }
    else {
        return (valStr) => valStr;
    }
}
function isSameType(value1, value2) {
    return ((value1 instanceof Date && value2 instanceof Date) || typeof value1 === typeof value2);
}
function getParamType(key, value) {
    if (value === null) {
        throw new Error(`Query parameter '${key}': Null value not allowed`);
    }
    else if (typeof value === 'boolean') {
        return { type: ParamType.Boolean };
    }
    else if (typeof value === 'string') {
        return { type: ParamType.String };
    }
    else if (typeof value === 'number') {
        return Number.isInteger(value)
            ? { type: ParamType.Integer }
            : { type: ParamType.Float };
    }
    else if (value instanceof Date) {
        return { type: ParamType.TimeStamp };
    }
    else if (Array.isArray(value)) {
        if (value.length) {
            const isUniformArray = value.every((val) => isSameType(val, value[0]));
            if (isUniformArray) {
                const firstElemType = getParamType(key, value[0]);
                return {
                    type: ParamType.Array,
                    arrayType: firstElemType,
                };
            }
            else {
                throw new Error(`Query parameter '${key}': Array must have uniform values`);
            }
        }
        else {
            throw new Error(`Query parameter '${key}': Empty array not allowed`);
        }
    }
    else {
        throw new Error(`Query parameter '${key}': Invalid Parameter Type ${JSON.stringify(value)}`);
    }
}
const convertValue = (value) => value instanceof Date ? value.toISOString() : `${value}`;
function getParamValue(value) {
    if (Array.isArray(value)) {
        const arrVal = value;
        return { arrayValues: arrVal.map((val) => ({ value: convertValue(val) })) };
    }
    else {
        return { value: convertValue(value) };
    }
}
function buildParams(params) {
    return Object.keys(params).map((key) => ({
        name: key,
        parameterType: getParamType(key, params[key]),
        parameterValue: getParamValue(params[key]),
    }));
}
async function query(projectId, querySQL, params = {}) {
    const debugQuery = removeSpace(querySQL);
    const qParams = buildParams(params);
    const start = Date.now();
    let resp2;
    try {
        resp2 = await getGAPI().request(`${prjPrefix}/${projectId}/queries`, {
            method: 'POST',
            json: {
                query: querySQL,
                queryParameters: qParams,
                useLegacySql: false,
                parameterMode: 'NAMED',
            },
        });
    }
    catch (err) {
        if (is404(err) || isNoMatchingTables(err)) {
            logger.log(`bquery.404 ${debugQuery}`);
            return emptyTable();
        }
        else {
            logger.error(`bigquery.fail ${debugQuery}`);
            throw err;
        }
    }
    const resp = await waitForQueryComplete(projectId, resp2);
    const took = Date.now() - start;
    const cost = resp.cacheHit ? 'cached' : resp.totalBytesProcessed;
    logger.log(JSON.stringify({ module: 'bigquery', took, cost, query: debugQuery }));
    const { fields } = resp.schema;
    const fieldParsers = fields.map(getFieldParser);
    const rowParser = (bqRow) => bqRow.f.map((cell, i) => fieldParsers[i](cell.v));
    return { columns: fields, rows: (resp.rows || []).map(rowParser) };
}
exports.default = query;
async function waitForPaginationQueryComplete(projectId, resp) {
    const { jobId } = resp.jobReference;
    if (resp.jobComplete) {
        return resp;
    }
    else {
        await delay(500);
        const resp2 = await getGAPI().request(`${prjPrefix}/${projectId}/queries/${jobId}`, {
            method: 'GET',
        });
        return waitForPaginationQueryComplete(projectId, resp2);
    }
}
async function queryWithPagination(projectId, querySQL, params = {}, options = {}) {
    var _a;
    const { maxResults = 20, jobId, pageToken } = options;
    let resp;
    const debugQuery = removeSpace(querySQL);
    const qParams = buildParams(params);
    try {
        if (pageToken && jobId) {
            resp = await getGAPI().request(`${prjPrefix}/${projectId}/queries/${jobId}`, {
                method: 'GET',
                searchParams: { pageToken, ...params },
            });
        }
        else {
            const resp2 = await getGAPI().request(`${prjPrefix}/${projectId}/queries`, {
                method: 'POST',
                json: {
                    query: querySQL,
                    queryParameters: qParams,
                    useLegacySql: false,
                    parameterMode: 'NAMED',
                    maxResults,
                },
            });
            resp = await waitForPaginationQueryComplete(projectId, resp2);
        }
    }
    catch (err) {
        if (is404(err) || isNoMatchingTables(err)) {
            logger.log(`bquery.404 ${debugQuery}`);
            return emptyTable();
        }
        else {
            logger.error(`bigquery.fail ${debugQuery}`);
            throw err;
        }
    }
    const start = Date.now();
    const took = Date.now() - start;
    const cost = resp.cacheHit ? 'cached' : resp.totalBytesProcessed;
    logger.log(JSON.stringify({ module: 'bigquery', took, cost, query: debugQuery }));
    const { fields } = resp.schema;
    const fieldParsers = fields.map(getFieldParser);
    const rowParser = (bqRow) => bqRow.f.map((cell, i) => fieldParsers[i](cell.v));
    return {
        columns: fields,
        rows: (resp.rows || []).map(rowParser),
        pageToken: resp === null || resp === void 0 ? void 0 : resp.pageToken,
        jobId: (_a = resp === null || resp === void 0 ? void 0 : resp.jobReference) === null || _a === void 0 ? void 0 : _a.jobId,
        totalRows: resp === null || resp === void 0 ? void 0 : resp.totalRows,
    };
}
exports.queryWithPagination = queryWithPagination;
