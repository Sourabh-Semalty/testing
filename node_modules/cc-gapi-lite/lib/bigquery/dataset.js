"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.Dataset = exports.JobState = exports.FieldMode = exports.FieldType = void 0;
const gapi_lite_1 = __importDefault(require("../gapi-lite"));
const logger_1 = __importDefault(require("cc-utils/logger"));
const scopes = ['https://www.googleapis.com/auth/bigquery'];
const apiBase = 'https://www.googleapis.com/bigquery/v2/projects';
let singleton = null;
function getGAPI() {
    if (!singleton)
        singleton = new gapi_lite_1.default(scopes);
    return singleton;
}
var FieldType;
(function (FieldType) {
    FieldType["String"] = "STRING";
    FieldType["Integer"] = "INTEGER";
    FieldType["Float"] = "FLOAT";
    FieldType["TimeStamp"] = "TIMESTAMP";
    FieldType["Record"] = "RECORD";
    FieldType["Boolean"] = "BOOLEAN";
})(FieldType = exports.FieldType || (exports.FieldType = {}));
var FieldMode;
(function (FieldMode) {
    FieldMode["Required"] = "REQUIRED";
    FieldMode["Repeated"] = "REPEATED";
})(FieldMode = exports.FieldMode || (exports.FieldMode = {}));
var JobState;
(function (JobState) {
    JobState["Done"] = "DONE";
    JobState["Pending"] = "PENDING";
    JobState["Running"] = "RUNNING";
})(JobState = exports.JobState || (exports.JobState = {}));
const logger = new logger_1.default('bq-dataset');
class Dataset {
    constructor(projectId, datasetId) {
        this.projectId = projectId;
        this.datasetId = datasetId;
    }
    async getTableInfo(tableId) {
        const { projectId, datasetId } = this;
        return getGAPI().tryGet(`${apiBase}/${projectId}/datasets/${datasetId}/tables/${tableId}`);
    }
    async getJob(jobId) {
        const { projectId } = this;
        return getGAPI().tryGet(`${apiBase}/${projectId}/jobs/${jobId}`);
    }
    async createLoadJob(tableId, jobId, gsURI) {
        const { projectId, datasetId } = this;
        await getGAPI().request(`${apiBase}/${projectId}/jobs`, {
            method: 'POST',
            searchParams: { uploadType: 'multipart' },
            json: {
                jobReference: { projectId, jobId },
                configuration: {
                    load: {
                        destinationTable: { projectId: projectId, datasetId, tableId },
                        sourceFormat: 'NEWLINE_DELIMITED_JSON',
                        sourceUris: [gsURI],
                    },
                },
            },
        });
    }
    async createTable(tableId, tblResource) {
        const { projectId, datasetId } = this;
        await getGAPI().request(`${apiBase}/${projectId}/datasets/${datasetId}/tables`, {
            method: 'POST',
            json: {
                tableReference: { projectId, datasetId, tableId },
                ...tblResource,
            },
        });
    }
    async patchTable(tableId, tblResource) {
        const { projectId, datasetId } = this;
        await getGAPI().request(`${apiBase}/${projectId}/datasets/${datasetId}/tables/${tableId}`, {
            method: 'PATCH',
            json: {
                tableReference: { projectId, datasetId, tableId },
                ...tblResource,
            },
        });
    }
    async createTableIfNotExists(tableId) {
        let tblInfo = await this.getTableInfo(tableId);
        if (tblInfo === null) {
            if (/_[a-z0-9_]+$/.test(tableId)) {
                // if it is domain table, copy schema from reference table
                const refTableId = tableId.replace(/_[a-z0-9_]+$/, '').replace(/^test/, '');
                const refTblInfo = await this.getTableInfo(refTableId);
                if (refTblInfo === null || !refTblInfo.schema) {
                    throw new Error(`missing.refTable.schema ${refTableId}:${tableId}`);
                }
                else {
                    let newResource = {};
                    if (refTblInfo.externalDataConfiguration) {
                        newResource.externalDataConfiguration = refTblInfo.externalDataConfiguration;
                        newResource.externalDataConfiguration.schema = refTblInfo.schema;
                    }
                    else {
                        newResource.schema = refTblInfo.schema;
                        newResource.timePartitioning = refTblInfo.timePartitioning;
                    }
                    logger.log('bq.create', { tableId, refTableId, newResource });
                    await this.createTable(tableId, newResource);
                    return refTblInfo.schema;
                }
            }
            else {
                throw new Error(`missing.table.schema ${tableId}`);
            }
        }
        else {
            return tblInfo.schema;
        }
    }
}
exports.Dataset = Dataset;
