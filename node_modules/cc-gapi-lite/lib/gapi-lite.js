"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const logger_1 = __importDefault(require("cc-utils/logger"));
const fs_1 = __importDefault(require("fs"));
const got_1 = __importDefault(require("got"));
const http_1 = __importDefault(require("http"));
const https_1 = __importDefault(require("https"));
const jws_1 = __importDefault(require("jws"));
const agent = {
    http: new http_1.default.Agent({ keepAlive: true }),
    https: new https_1.default.Agent({ keepAlive: true }),
};
const logger = new logger_1.default('gapi');
const GOOGLE_TOKEN_URL = 'https://accounts.google.com/o/oauth2/token';
const RETRY_CONFIG = {
    limit: 5,
    methods: ['GET', 'PATCH', 'POST', 'PUT'],
    statusCodes: [408, 413, 429, 500, 502, 503, 504],
};
function is404(err) {
    return err instanceof got_1.default.HTTPError && err.response.statusCode === 404;
}
class GoogleAPI {
    constructor(scopes) {
        const jsonPath = process.env.GOOGLE_APPLICATION_CREDENTIALS || '/home/convertcart/Downloads/t-beta-gcloud.json';
        if (!jsonPath)
            throw new Error('env.not.set GOOGLE_APPLICATION_CREDENTIALS');
        this.authKey = JSON.parse(fs_1.default.readFileSync(jsonPath).toString());
        this.scope = scopes.join(' ');
        this.expiry = 0;
        this.token = '';
        this.alreadyPromised = null;
    }
    async getToken() {
        if (this.expiry > Date.now()) {
            return this.token;
        }
        else {
            if (this.alreadyPromised) {
                const val = await this.alreadyPromised;
                return val;
            }
            else {
                this.alreadyPromised = this.getTokenInternal();
                const val = await this.alreadyPromised;
                this.alreadyPromised = null;
                return val;
            }
        }
    }
    async getTokenInternal() {
        const iat = Math.floor(Date.now() / 1000);
        const toSign = {
            header: { alg: 'RS256' },
            payload: {
                iss: this.authKey.client_email,
                scope: this.scope,
                aud: GOOGLE_TOKEN_URL,
                exp: iat + 3600,
                iat,
            },
            secret: this.authKey.private_key,
        };
        const body = {
            grant_type: 'urn:ietf:params:oauth:grant-type:jwt-bearer',
            assertion: jws_1.default.sign(toSign),
        };
        const result = await got_1.default.post(GOOGLE_TOKEN_URL, { form: body, agent }).json();
        this.token = result.access_token;
        this.expiry = Date.now() + (result.expires_in - 10) * 1000;
        logger.log('got.token', { account: this.authKey.client_email, scope: this.scope });
        this.alreadyPromised = null;
        return this.token;
    }
    async request(url, opts) {
        const tok = await this.getToken();
        try {
            const resp = await got_1.default(url, {
                agent,
                method: opts.method,
                headers: { Authorization: `Bearer ${tok}` },
                searchParams: opts.searchParams,
                responseType: opts.responseType || 'json',
                body: opts.body,
                json: opts.json,
                retry: opts.ccRetry ? RETRY_CONFIG : undefined,
            });
            return resp.body;
        }
        catch (err) {
            if (err instanceof got_1.default.HTTPError) {
                const { statusCode } = err.response;
                if (statusCode === 400 || statusCode === 403) {
                    const jbody = JSON.stringify(err.response.body);
                    throw new Error(`status.${statusCode} ${url} ${jbody}`);
                }
                else {
                    throw err;
                }
            }
            else {
                throw err;
            }
        }
    }
    // try 'get' resource, in case of 404 return null
    async tryGet(url) {
        try {
            return await this.request(url, { method: 'GET', responseType: 'json' });
        }
        catch (err) {
            if (is404(err))
                return null;
            else
                throw err;
        }
    }
    // try 'delete' resource, in case of 404 ignore
    async tryDelete(url) {
        try {
            await this.request(url, { method: 'DELETE', responseType: 'json' });
        }
        catch (err) {
            if (!is404(err))
                throw err;
        }
    }
}
exports.default = GoogleAPI;
